---
title: "Exercício 5: Gráficos, um tutorial com ggplot2"
author: "Vitor Aguiar"
output: html_document
---

[\@vitoaguiar](https://twitter.com/vitoaguiar)

Neste tutorial, vamos usar o pacote `ggplot2` para criar os gráficos do Exercício 5 do curso [_Using R_ do Departamento de Ecologia da Universidade de São Paulo](http://ecologia.ib.usp.br/bie5782/doku.php?id=start). 
Se você não tem esse pacote instalado, a primeira coisa a fazer é instalá-lo e carregá-lo na sessão de R. 
```{r message=FALSE, results='hide', eval=FALSE}
install.packages("ggplot2")
```

```{r message=FALSE}
library(ggplot2)
library(grid)
```

A estrutura básica de código para criar um ggplot é a seguinte:
```{r eval=FALSE}
ggplot(my_data_frame, aes(x, y)) + geom()
```

Primeiro criamos um plot com a função `ggplot`. 
O primeiro argumento é `data`, onde você especifica o _data frame_ com suas variáveis.
Depois vem o `mapping`. Nele você cria o "mapeamento" das variáveis, normalmente usando `aes` (de _aesthetics_). Ou seja, você especifica quais são as variáveis dos eixos _x_ e _y_, além de outras opções como cores e símbolos usados para plotar os dados.

Depois da função `ggplot`, nós especificamos um _geom_. Por exemplo, `geom_point` para plotar pontos, `geom_boxplot` para um boxplot, etc. Para a lista completa de _geoms_ e todas as outras opções do pacote, visite [a página do projeto ggplot2](http://docs.ggplot2.org/0.9.3.1/index.html).

Note que adicionamos um _geom_ com um "_+_". No `ggplot2`, nós criamos gráficos em camadas (_layers_), e adicionamos camada a camada com um "_+_".

Pois bem. Agora vamos partir para o exercício!

Vamos usar o dado esaligna:
```{r}
esaligna <- read.csv("http://ecologia.ib.usp.br/bie5782/lib/exe/fetch.php?media=dados:esaligna.csv")
```

### 5.1: Editando alguns parâmetros gráficos

Crie um gráfico de dispersão entre `dap` e `ht` com:

**1. Legendas dos eixos com nomes das variáveis e suas unidades**

```{r fig.align='center'}
# Criar o plot e salvar no objeto 'p'
p <- ggplot(esaligna, aes(x = dap, y = ht)) + 
  geom_point() +
  xlab("diâmetro na altura do peito (cm)") +
  ylab("altura do tronco (m)")

# Execute 'p' para visualizar:
p
```

Note que, assim como a função `plot` do R, também temos argumentos `xlab` e `ylab`, mas aqui eles são adicionados com um "_+_".
  
**2. Marcações do eixos (ticks) para dentro da área do gráfico**

Como salvamos o plot no objeto `p`, podemos reutilizá-lo e adicionar camadas.
```{r fig.align='center'}
p + 
  theme_bw() + 
  theme(axis.ticks.length = unit(-0.25, "cm"), 
        axis.ticks.margin = unit(0.5, "cm"))
```

Para colocar os _ticks_ para dentro do gráfico, primeiro configuramos o _background_ para a cor branca com `theme_bw()` (de _black and white_). Assim podemos visualizar melhor os _ticks_.
E então editamos os _ticks_ com `theme()` "setando" a opção `axis.ticks.length` com um valor negativo para que os _ticks_ fiquem para dentro do gráfico. E então especificamos um valor de 0.5 para o `axis.ticks.margin` para aumentar a distância dos _ticks_ para os _tick labels_, assim eles não ficam sobrepostos. Para isso, usamos a função `unit` do pacote `grid`, o qual carregamos no início desse tutorial.

**3. Apenas dois eixos (formato “L”)**

Uma alternativa para criar um gráfico no formato "L" é usar `theme_classic()`.
Isso também remove as linhas de grid. É mais fácil adicionar `theme_classic()` antes de `theme()` para evitar apagar as configurações de _ticks_ que criamos.
```{r fig.align='center'}
p <- p + 
  theme_bw() + 
  theme_classic() +
  theme(axis.ticks.length = unit(-0.25, "cm"), 
        axis.ticks.margin = unit(0.5, "cm"))

p
```

**4. Título informativo**

Podemos adicionar um título com `labs()`:

```{r fig.align='center'}
p <- p + labs(title = "relação entre dap e altura do tronco")

p
```

**5. Tamanho das fontes maiores que o padrão**

Para aumentar o tamanho da fonte, também podemos usar `theme()`. No `ggplot2`, _axis labels_ são chamadas de `axis.title` e _tick labels_ de `axis.text`.
```{r fig.align='center'}
p + theme(axis.title = element_text(size = 18),
          axis.text = element_text(size = 14))
```

### 5.2 Dois gráficos juntos

**1. Use as variáveis `dap` e `talhao` para construir dois gráficos, colocando-os lado a lado. O primeiro deve ser um gráfico de desenho de caixa (boxplot) da variável `dap` em função do fator `talhao`. O segundo deve ter apenas a média e uma barra de desvio-padrão do `dap`, para cada `talhao`.**

```{r comment=""}
# Boxplot
p_box <- ggplot(esaligna, aes(factor(talhao), dap)) +
  geom_boxplot() +
  xlab("talhao")
  
# Para criar o segundo gráfico, vamos primeiro criar um data.frame com as médias
# e desvios padrão para cada talhão:
dat_por_talhao <- data.frame(talhao = sort(unique(esaligna$talhao)), 
                             media = with(esaligna, tapply(dap, talhao, mean)), 
                             sd = with(esaligna, tapply(dap, talhao, sd)))

dat_por_talhao

# Agora vamos criar o gráfico:
p_media_desvio <- ggplot(dat_por_talhao, aes(factor(talhao), media)) + 
  geom_point(stat = "identity", size = 5) + 
  geom_errorbar(aes(ymin = media - sd, ymax =  media + sd), width = 0.5) +
  xlab("talhao")
``` 

Vimos algumas coisas novas para criar o gráfico `p_media_desvio`.
Dentro de `geom_point()`, especificamos `stat = "identity"`. Isso diz ao ggplot que já estamos dando a ele o valor da média calculada, e que ele não deve calcular isso dos dados. Além disso, usamos `size = 5` para aumentar o tamanho dos pontos no gráfico.
Então, adicionamos a barra do desvio padrão com `geom_errorbar()` especificando que queremos que a barra seja desenhada a partir dos pontos `media - sd` até os pontos `media + sd`.

Para colocar ambos os gráficos na mesma janela, vamos usar a função `pushViewport` do pacote `grid`.
Primeiro criamos nosso sistema de janelas especificando que queremos 1 linha e 2 colunas, como em `par(mfrow=c(1, 2))`. Depois "imprimimos" cada gráfico em sua posição. 

```{r fig.width = 10, fig.height = 6}
pushViewport(viewport(layout = grid.layout(1, 2)))
print(p_box, vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
print(p_media_desvio, vp = viewport(layout.pos.row = 1, layout.pos.col = 2))
```

**2. Insira também uma letra para dizer qual é o gráfico “a” e qual é o “b” (tanto faz, quem é um e quem é outro).**

Podemos adicionar a letra com `labs()` na forma de título e, se desejado, usar `hjust = 0` para justificar o título a esquerda:
```{r fig.width = 10, fig.height = 6}
pushViewport(viewport(layout = grid.layout(1, 2)))
print(p_box + labs(title = "a)") + theme(plot.title = element_text(hjust = 0)), 
      vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
print(p_media_desvio + labs(title = "b)") + theme(plot.title = element_text(hjust = 0))
      ,vp = viewport(layout.pos.row = 1, layout.pos.col = 2))
```

### 5.3 Adivinhando o código

Vamos criar a versão ggplot da [figura do exercício 5.3](http://ecologia.ib.usp.br/bie5782/lib/exe/detail.php?id=bie5782%3A01_curso_atual%3Aexercicios5&media=bie5782:01_curso2009:material:exercicio3.jpeg)

Primeiro, lemos o dado misterioso:
```{r}
dat <- read.csv("http://ecologia.ib.usp.br/bie5782/lib/exe/fetch.php?media=bie5782:01_curso2009:material:exercicio3.csv")
```

E então vamos ao primeiro plot:
```{r}
p_a <- ggplot(data = dat, aes(x1, y1)) + 
  geom_point(size = 3, alpha = .65, na.rm = TRUE) + 
  geom_smooth(method = "lm", se = FALSE, na.rm = TRUE) +
  xlab("Log(Patch size)(ha)") +
  ylab("Euclidean distances")
```

Aqui nós usamos em `geom_point()` os argumentos `size = 3` para aumentar um pouco o tamanho dos pontos, `alpha = 0.65` para adicionar uma transparência aos pontos e `na.rm = TRUE` pois o dados tem alguns valores faltantes. Esse último argumento não é necessário, uma vez que o `ggplot2` vai eliminar esses valores automaticamente, nos emitindo uma mensagem de aviso.

Em `geom_smooth()` adicionamos uma linha _smooth_ ao plot de acordo com o modelo de regressão linear.

Enfim vamos ao último plot desse tutorial!
```{r}
p_b <- ggplot(data = dat, aes(factor(y2), x2)) + 
  ylim(c(0,3)) +
  geom_boxplot(outlier.shape = NA) +
  stat_boxplot(geom ='errorbar') + 
  scale_x_discrete(labels=c("Small", "Medium\nEdge", "Medium\nInterior",
                            "Large\nEdge", "Large\nInterior", "Control")) +
  theme(axis.title = element_blank()) +
  annotate("text", x = 1:6, y = 3, label = c("*", "*", "**", "*", "***", ""), 
           size = 12)
```

Nesse boxplot nós usamos

* `outlier.shape = NA` para remover outliers do plot
* `stat_boxplot(geom = "errorbar")` como um truque para adicionar linhas horizontais ao fim dos _whiskers_
* `scale_x_discrete()` para adicionar os nomes no eixo _x_ (_discrete_ porque temos um eixo _x_ categórico)
* `theme(axis.title = element_blank())` para remover os _axis labels_
* `annotate()` para adicionar os asteriscos ao plot.

Para finalizar, colocamos os 2 plots lado a lado com a `pushViewport()` que vimos anteriormente:
```{r fig.width = 10, fig.height = 6, message=FALSE, warning=FALSE}
pushViewport(viewport(layout = grid.layout(1, 2)))
print(p_a + labs(title = "a)") + theme(plot.title = element_text(hjust = 0)),
      vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
print(p_b + labs(title = "b)") + theme(plot.title = element_text(hjust = 0)),
      vp = viewport(layout.pos.row = 1, layout.pos.col = 2))
```

***Note que o comportamento do `ggplot2` para calcular o comprimento dos _whiskers_ no boxplot é diferente da função `boxplot` do R. [A página do pacote traz mais detalhes sobre isso](http://docs.ggplot2.org/current/geom_boxplot.html).**
